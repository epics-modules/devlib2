<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>devLib2: VME64 CSR Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">devLib2
   &#160;<span id="projectnumber">2.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">devLib2 MMIO Bus Access Library</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">VME64 CSR Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When working with a CSR/CR device the first step is to find the identifiers for the board. This should be included in vendor documentation, and can be verified by probing the appropriate VME slot at runtime. The library functions vmecsrdump(lvl) and vmecsrprint(slot,lvl) can be used for this. See the IOC shell section for detail on these functions.</p>
<p>Including this identifying information in your code provides an important safe guard against user mis-configuration. This provides an easy way to prevent your code from trying to access the wrong type of device.</p>
<p>To initialize you must know its slot number. While it is possible to automatically detect cards it is preferable to have a user defined mapping between physical id (slot#) and logical id (Asyn port, device ID, etc.). This allows for consistent naming even if cards are added or removed from the system.</p>
<p>For EPICS drivers initialization will usually be done with an IOC shell function. For example:</p>
<div class="fragment"><div class="line">myVMECardSetup(<span class="stringliteral">&quot;dac&quot;</span>, 5, 0x210000, 4, 0x60)</div></div><!-- fragment --><p>Would set card "dac" to be the card in slot 5. This imaginary card is given an A24 base address of 0x210000, and set to generate interrupt vector 0x60 at level 4.</p>
<p>Below is an example implementation of myVMECardSetup().</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="struct_v_m_e_c_s_r_i_d.html">VMECSRID</a> mydevids[] = {...}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">myVMECardSetup(<span class="keyword">const</span> <span class="keywordtype">char</span>* port,</div><div class="line">               <span class="keywordtype">int</span> slot,</div><div class="line">               <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> base,</div><div class="line">               <span class="keywordtype">int</span> level,</div><div class="line">               <span class="keywordtype">int</span> vector)</div><div class="line">{</div><div class="line">    <span class="keyword">volatile</span> <span class="keywordtype">void</span>* csr, a24;</div><div class="line">    devpriv *priv;</div><div class="line">    <span class="keywordflow">if</span>( portExists(port) ) <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">    csr=<a class="code" href="group__vmecsr.html#ga9316a3d969fc1eb17312a91e3e169f05">devCSRTestSlot</a>(mydevids, slot, NULL);</div><div class="line">    <span class="keywordflow">if</span> (!csr) <span class="keywordflow">return</span> 2;</div></div><!-- fragment --><p>The first step is to probe the VME slot and get the CSR base address. If the slot were empty or populated with an unsupported card then we would abort here.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if card is VME64</span></div><div class="line">    <a class="code" href="group__vmecsr.html#gacccc26fbc8b0eea78622c06f9ee9a86f">CSRWrite24</a>(csr + MYCSR_BAR_BASE, base);</div><div class="line"></div><div class="line"><span class="preprocessor">#elif card is VME64x</span></div><div class="line">    <a class="code" href="group__vmecsr.html#ga99703c846bd1e79b76785c03220047a8">CSRSetBase</a>(csr, 0, base, <a class="code" href="vmedefs_8h.html#ab5690987e7af533794038ee246c0a0ad">VME_AM_STD_SUP_DATA</a>);</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>Assuming the card supports full jumperless configuration then then base address will be programmed using the CSR space. While newer VME64x cards have standard base address registers for this, older VME64 cards do not. For these card the vendor should document the correct way to set the base address.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="devlib__dummy_8c.html#af4f0320be69231415afbdb4f462042b1">devRegisterAddress</a>(<span class="stringliteral">&quot;mydrv&quot;</span>, atVMEA24, base, 0xff, &amp;a24))</div><div class="line">    <span class="keywordflow">return</span> 3;</div></div><!-- fragment --><p>Once the A24 base address is set we map it into the process' address space with the standard devLib mapping call.</p>
<div class="fragment"><div class="line">priv=calloc(1, <span class="keyword">sizeof</span>(mydevpriv));</div><div class="line"><span class="keywordflow">if</span> (!priv) <span class="keywordflow">return</span> 4;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (devConnectInterruptVME(vector&amp;0xff, &amp;myisr, priv))</div><div class="line">    <span class="keywordflow">return</span> 5;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (devEnableInterruptLevelVME(level&amp;0x7)) <span class="keywordflow">return</span> 6;</div></div><!-- fragment --><p>Always attach the interrupt handler before enabling interrupts.</p>
<div class="fragment"><div class="line"><a class="code" href="group__vmecsr.html#gaa1378a006ef6227b68a2a5f8230bf324">CSRWrite8</a>(csr + MYCSR_IRQ_LEVEL, level&amp;0x7);</div><div class="line"><a class="code" href="group__vmecsr.html#gaa1378a006ef6227b68a2a5f8230bf324">CSRWrite8</a>(csr + MYCSR_IRQ_VECTOR, vector&amp;0xff);</div></div><!-- fragment --><p>Neither VME64 or VME64x specifies standard registers for interrupt level or vector code. Vendor documention must specify how to set this.</p>
<p>.Note</p>
<p>This may not be done in the CSR space, but rather in another address space.</p>
<div class="fragment"><div class="line">    portCreate(port, priv);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
